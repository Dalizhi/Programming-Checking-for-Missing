### 目录
- [typedef 声明](#typedef-声明)
- [枚举类型](#枚举类型)
- [变量声明](#变量声明)
- [局部变量与全局变量](#局部变量与全局变量)
- [定义常量](#定义常量)
    - [#define预处理](#define预处理)
    - [const](#const)
    - [宏定义 #define 和常量 const 的区别](#宏定义-define-和常量-const-的区别)
- [修饰符 const](#修饰符-const)
    - [const 与指针](#const-与指针)

### typedef 声明
可以使用 typedef 为一个已有的类型取一个新的名字。  
typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。  
用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。
```cpp
typedef int feet;//告诉编译器，feet 是 int 的另一个名称：可以理解 feet 为 int 的别名
feet distance;//它创建了一个整型变量 distance
```

### 枚举类型
如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。每个枚举元素在声明时被分配一个整型值，默认从 0 开始，逐个加 1。也可以在声明时将枚举元素的值一一列举出来。  
注意
- 枚举元素是常量，除了初始化时不可给它赋值。
- 枚举变量的值只可取列举的枚举元素值。
```cpp
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
     标识符[=整型常数]
} 枚举变量;
```

如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。
```cpp
enum color { red, green, blue } c;
c = blue;//c 为枚举变量，把枚举元素 blue 赋给 c，此时 c = 2
// 若直接这样赋值 c = 2；就会报错！你只能把{ red, green, blue }赋值给 c。
// blue = 2；报错！blue 是常量而不是变量。
//未初始化默认red = 0,green = 1, blue = 2
```
若给某一个标识符赋值如 green = 5
```cpp
enum color { red, green = 5, blue } c;
c = blue;//6
//部分值初始化，要满足后面的值比前面值大 1，此时 red 默认为 0
//green 初始化为 5 ，blue 要满足比 green 大 1 即 blue = 6
```

### 变量声明
使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。可以使用 extern 关键字在任何地方声明一个变量。**虽然可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。**
```cpp
int a = 0;     //定义并声明了变量 a
extern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。
```
extern用在变量声明中常常有这样一个作用，你在*.cpp文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。

### 局部变量与全局变量
局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。
```cpp
#include <iostream>
using namespace std;
// 全局变量声明
int g = 20;
int main ()
{
  // 局部变量声明
  int g = 10;
  cout << g;
  return 0;
}
//打印10。
```
### 定义常量
#### #define预处理
```cpp
#define PI 3.14156
#define A 2+3
```
编译预处理可以理解为简单的字符替换，用时最好加括号。
详见[C/9.编译预处理.md](../C/9.编译预处理.md)
#### const
const 声明指定类型的常量
```cpp
const int LENGTH = 10;
// LENGTH = 15;报错！LENGTH 是常量，不能再为它赋值了。
```
#### 宏定义 #define 和常量 const 的区别
- *类型和安全检查不同：*    
宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；  
const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查

- *编译器处理不同：*   
宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束于编译时期；  
const常量是一个"运行时"概念，在程序运行时使用，类似于一个只读行数据。

- *存储方式不同：*  
宏定义是直接替换，不会分配内存，存储于程序的代码段中；  
const常量需要进行内存分配，存储于程序的数据段中。
- *定义域不同：*
```cpp
void f1 ()
{
    #define N 12
    const int n 12;
}
void f2 ()
{
    cout<<N <<endl; //正确，N已经定义过，不受定义域限制
    cout<<n <<endl; //错误，n定义域只在f1函数中
}
```
- *定义后能否取消：*  
宏定义可以通过#undef来使之前的宏定义失效；  
const常量定义后将在定义域内永久有效。
```cpp
void f1()
{
  #define N 12
  const int n = 12;

  #undef N //取消宏定义后，即使在f1函数中，N也无效了
  #define N 21//取消后可以重新定义
}
```
- *是否可以做函数参数：*  
宏定义不能作为参数传递给函数；    
const常量可以在函数的参数列表中出现。

- const限定符定以后是不可以改变的，所以在定义时必须赋初始值，要不然是错误的，除非这个变量是用extern修饰的外部变量。 例如：
```cpp
const int A=10;       //正确。
const int A;          //错误，没有赋初始值。
extern const int A;   //正确，使用extern的外部变量。
```
### [修饰符 const](https://zhuanlan.zhihu.com/p/37514756)
#### const 与指针
指针本身是一个独立的对象，它又可以指向另一个对象。所以指针和const同时使用时，有两种情况：
```cpp
int i = 0;
int *const j = &i;
//指针常量,指向不可变地址的指针，但可以对它指向的内容进行修改。
// 指针j指向i，const修饰指针j本身，
//所以j的地址值不允许修改，但可以通过j修改i的值
const int *k = &i;
//常量指针，指向常量的指针，该指针指向的地址里的内容不可变。
// 指针k指向i，const修饰k指向的i，
//所以k的地址值可以修改，但不可以通过k修改i的值
int const *p = &i;
//即 const int *p，同上，为常量指针。
//const 修饰离右边最近的那一个，int const *p 等价于 const int *p
//都可以理解为 const 修饰（*p）而不是 p，那么 p 可变,p 指向的值不可变
```

