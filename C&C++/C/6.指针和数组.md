### 指针和一维数组
大部分指针运算都是针对数组中的数据元素进行相关运算的。  
事实上，定义一个数组short num[10];后，num便被编译系统转换为一个指向num[0]的short型地址常量，num[i]也被编译系统解释为\*(num+i)。num[i]的地址&num[i]等价于num+i。  
此时若有语句“short \*p = num;”，使p指向num[0],则
- &p[i]等价于p+i等价于&num[i]等价于num+i
- p[i]等价于\*(p+i)等价于num[i]等价于\*(num+i)

### 指向数组元素的指针变量与数组的数据类型必须一致
```C
int num[] = {2,4,6}; 
short *p = num; //逻辑上没有问题，但如果通过p自增来取数组里的数据就会有问题
//因为int *型指针p,p+1，是每隔四个字节取一个数据，
//而short *型指针p,p+1每移动两个字节取一个数据，读取数据的时候，会很有问题。
```

### 指针和二维数组
行地址是C语言里的二级指针，它代表某一行（可以看成是以为数组）的地址，而不是一个具体数据的地址。  
列地址是C语言里的一级地址，它代表一个具体数据的地址。
定义一个三行三列的二维数组
```C
short Array[3][3]；
```
可以将Array看作一个特殊的一维数组：S[3],它由原数组里的每一行Array[0], Array[1], Array[2]组成，而每一个数组元素又分别是一个一维数组，如Array[1]数组含有Array[1][0], Array[1][1], Array[1][2]三个元素。  
一维数组名代表一维数组的起始地址，把Array理解为是特殊一维数组S[3]={Array[0], Array[1], Array[2]}的数组名(S中每一个元素都是Array中的一行元素)，那么S和Array都代表Array[0]~Array[2]的起始地址&Array[0]、Array+0，同时S中数组元素Array[0]也即\*(Array+0)。同理，Array+1代表Array索引为1的行的地址，也是S中索引为1元素的地址, Array[1]=\*(Array+1)。    
对索引为1的行Array[1]而言，它由三个元素Array[1][0]、Array[1][1]、Array[1][2]组成，直接把Array[1]看作是一个数组名A，则Array[1]中的三个元素可记之为{A[0],A[1],A[2]}，那么A[2]=Array[1][2]   
&A[2]=&Array[1][2]=Array[1]+2=\*(Array+1)+2。    
A[2]=\*&A[2]=\*&Array[1][2]=\*(Array[1]+2)=\*(\*(Array+1)+2)  
同理：  
A[0]=Array[1][0],  
&A[0]=&Array[1][0]=Array[1]+0=Array[1]=\*(Array+1)+0=\*(Array+1)。  
A[0]=\*&A[0]=\*&Array[1][0]=\*(Array[1]+0)=\*Array[1]=\*(\*(Array+1)+0)=\*(\*(Array+1))=\*\*(Array+1)。

### 数组指针
又称行指针变量。首先它是一个指针，该指针指向一维数组。
```C
//类型说明符 （*变量名）[一维数组长度];
short (*p)[3];//p是一个指针，该指针指向一个包含3个元素的一维数组。
//[]操作优先级大于*操作
short Array[][3] = {{1,2,3},{4,5,6},{7,8,9}};
p = Array;//或者p = &Array[0];
//个人理解：这不是把Array赋值给p，
//而是把Array的索引为0的行的地址（也即整个Array的起始地址）赋给p
```
假设 *i, j* 都在合理的范围  
```C
p[i][j]=Array[i][j]
*(*(p+i)+j)=*(*(Array+i)+j)
*(p[i]+j)=*(Array[i]+j)
(*(p+i))[j]=(*(Array+i))[j]
```
### 指针数组
如果数组中的每一个元素都是同类型的指针，该数组便称为指针数组。  
首先指针数组是一个数组，数组里的元素都是指针。
```C
//类型说明符 *指针数组名[数组长度]；
char *str[5]={"VB","C","C++","Python","JAVA"};
char *tmp;
tmp = str[1];
```
当指针里的每一个元素都指向一个一维数组时，指针数组就相当于二维数组的多个行地址（数组指针），指针数组名就相当于二维数组名。指针数组与二维数组的区别在于：指针数组中的每一个元素所指向的一维数组长度可以不一，一维数组之间也不需要在内存中连续存放，指针数组中的每一个元素均为指针变量，地址可变。  
指针数组特别适合处理若干长短不一的字符串。

### 数组指针与指针数组
```C
type (*p)[]; //数组指针
/*
type a[]，a 是一个数组，数组内元素都是 type 类型，将 a 换成 (*p)，
可以理解为 （*p）是一个数组，数组内元素都是 type 类型，那么 p 就是指向这样的数组的指针，即数组指针。

*/

type *p[]; //指针数组
/*
type *p[]即(type *)p[]，则 p 是一个 type* 类型的数组(类比int a[10]，a 是 int 型数组）
即 p 是一个数组，数组内元素都是指针（ type *）
*/
```

### 指针和字符串
```C
int a = 5;
int *pa = &a;
char *s = "C++";
char string[] = "Python";
/*int *pa = 5；有问题，怎么能把变量赋值给一个地址？
但 char *s = "C++";就可以，这是把一个字符串的首地址赋给指针。
从形式上来看，char * 型指针指向一个char型数组（字符串）,
而 int * 型指针却只指向一个int型变量。
*/
```
char \*s 和 char string[]还是不同的：  
- 存储内容不同：字符数组存储字符串， 字符指针里存储地址。
- 存储空间长度不同：字符数组一旦定义，所指向的存储空间的大小就已经确认下来；字符指针变量占用的字节数是地址所需的长度，与字符串无关。
- 运算不同：字符数组名是地址常量，不能改变，字符指针变量可以参加指针运算。地址可变。
```C
s = "JAVA";//直接将一个字符串赋值给char * 型指针。
//下面三个将字符数组地址赋给char *型指针效果都一样
s = string;//字符数组名即字符数组地址
s = &string;//相当于&string[0],即字符数组第一个元素的地址。
s = &string[0];
```

