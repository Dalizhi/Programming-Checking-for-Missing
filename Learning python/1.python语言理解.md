### python运行过程
迄今为止，我们大多数将 python 作为一门编程语言来介绍，但从实现来看，python 也是一个名为**解释器**的软件包。
解释器是一个让其他程序运行起来的程序。当你编写了一段python程序后，python解释器将读取程序，并按照其中的命令执行，得出结果。
实际上，解释器是代码与机器硬件之间的软件逻辑层。 

按照惯例，python是以.py结尾的。从技术上讲，这种命名方案在导入时才是必须的，
你可以用任何自己喜欢的文本编辑器创建以其它扩展名结尾的文件，但大多数python文件为了统一都是以.py结尾命名的。
你在文本文件中输入代码，之后在解释器中运行这些代码。   

执行程序时，python内部（对大多数用户完全隐藏）会先将源代码编译成字节码。
编译是一个简单的翻译步骤，字节码是一个低级的与平台无关的表现形式。这些字节码比文本文件中的源代码语句的运行速度快的多。
如果python进程在机器上具有写入权限，那么它会将字节码保存在一个以.pyc为扩展名的文件中。
python保存字节码是对启动速度的一个优化。如果下次启动时，源代码没有修改，并且使用的python版本也没有改变，
那么python将会直接加载.pyc文件，并跳过编译这个步骤。如果python无法在机器上写入字节码，程序仍然可以工作：
字节码会在内存中生成，并在程序结束时被丢弃。  

一旦程序被编译成字节码，之后的字节码发送到python虚拟机（Python Virtual Machine，PVM）上来执行。
PVM就是迭代运行字节码指令的一个大循环，一个接一个地完成操作。
PVM是Python运行时的引擎，它时常表现为Python系统的一部分，并且是实际运行脚本的组件。
从技术上来说，它只是所谓Python解释器的最后一步。  

### python性能
与C/C++这类完全编译语言不同的是，python工作中通常没有构建或“make”的步骤：
代码写好后立即运行，另外一个就是 python 字节码不是机器的二进制代码，字节码是特定于 python 的一种表现形式。  
**这就是python代码无法像C/C++一样快的原因**。 PVM循环仍然需要解释字节码。  

### Cython
大多数使用的python都是Cython，是标准的实现，也是《Python学习手册》（*Learning Python*）这本们将要使用的。
其它版本的Python，有其各自的用途与功能。  
Cython它为代码配备了调用C函数以及使用变量、参数和类属性的C类型声明的能力。  
*Shed Skin*是python 到 C++ 的转换器。尝试将python代码翻译成C++代码，然后使用机器中的C++编译器将得到的C++代码编译为机器代码。  

### 冻结二进制文件
可以通过第三方工具将python程序转为可执行程序，他们在python世界中被称为冻结二进制文件（frozen binary）。
这些程序可以不安装python环境而独立运行。冻结二进制文件，能够将程序的字节码，PVM，
以及任何程序所需要的python支持文件捆绑在一起形成一个单独的文件包。
这个过程存在一些不同的变体，但最终的结果都会产生一个独立的可执行二进制程序，类似Windows系统中的.exe文件。   

### 编码声明
- #!/usr/bin/python：这句注释的作用是告诉文件中的代码是用什么编译器去执行；  
- #!/usr/bin/env python:这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
- -\*- coding:utf-8 -*-:这段注释是告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 

### 变量、对象和引用[B1P185-186]
- 变量永远不会拥有和它关联的类型信息或约束。类型的概念存在于对象而不是变量中。变量原本是通用的，他只是在一个特定的时间点，简单地引用了一个特定的对象而已。  
- 当变量出现在表达式中时，它会马上被当前引用的对象所替换，无论这个对象是什么类型。此外，所有的变量必须在使用前明确地被赋值，使用未赋值的变量会产生错误。  
- 简而言之，变量在赋值的时候才会被创建，它可以引用任何类型的对象，而且必须在引用之前赋值。  
- 语句 a=3,变量a实际是到对象内存空间（通过运行常量表达式3而创建）的一个指针。  

### 类型属于对象，而不是变量[B1P187]
```python
a = 3   
a = 'spam'   
a = 1.23  
```
变量名没有类型，类型属于对象，而不是变量。我们只是将变量修改为对不同变量的引用。只是让不同的变量名引用不同类型的对象。

### 对象的垃圾回收[B1P187]
```python
a = 3  
a = 'spam'  
```
a 引用的对象的类型改变，对象的引用值在此过程中逐个丢弃。a每次被赋值给一个新对象时，python都会回收之前对象的空间。在内部，python在每个对象中保留了一个计数器，计数器记录该对象的引用数目，一旦这个计数器被设置为0，这个对象的内存空间就会被回收。
